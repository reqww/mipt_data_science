# Задача 3. Минимизация негладкой функции Теперь рассмотрим функцию h(x) = int(f(x)) на том же отрезке [1, 30],
# т.е. теперь каждое значение f(x) приводится к типу int и функция принимает только целые значения.
#
# Такая функция будет негладкой и даже разрывной, а ее график будет иметь ступенчатый вид. Убедитесь в этом,
# построив график h(x) с помощью matplotlib.
#
# Попробуйте найти минимум функции h(x) с помощью BFGS, взяв в качестве начального приближения x=30. Получившееся
# значение функции – ваш первый ответ в этой задаче.
#
# Теперь попробуйте найти минимум h(x) на отрезке [1, 30] с помощью дифференциальной эволюции. Значение функции h(x)
# в точке минимума – это ваш второй ответ в этом задании. Запишите его через пробел после предыдущего.
#
# Обратите внимание на то, что полученные ответы различаются. Это ожидаемый результат, ведь BFGS использует градиент
# (в одномерном случае – производную) и явно не пригоден для минимизации рассмотренной нами разрывной функции.
# Попробуйте понять, почему минимум, найденный BFGS, именно такой (возможно в этом вам поможет выбор разных начальных
# приближений).
#
# Выполнив это задание, вы увидели на практике, чем поиск минимума функции отличается от глобальной оптимизации,
# и когда может быть полезно применить вместо градиентного метода оптимизации метод, не использующий градиент. Кроме
# того, вы попрактиковались в использовании библиотеки SciPy для решения оптимизационных задач, и теперь знаете,
# насколько это просто и удобно.

from scipy import optimize
from math import sin, exp
import numpy as np
from matplotlib import pyplot as plt


dist = [1, 30]


def h(x):
    return int(sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2))


def find_min_grad(func, coord, method="BFGS"):
    return optimize.minimize(func, np.array(coord), method=method, tol=1e-7)


def find_min_diff(func, coord):
    return optimize.differential_evolution(func, [coord])


bfgs_res = find_min_grad(h, 30)
print("bfgs:", bfgs_res)
print(round(h(bfgs_res.x[0]), 2))

diff_res = find_min_diff(h, dist)
print("diff:", diff_res)
print(round(h(diff_res.x[0]), 2))

x_arr = np.arange(dist[0], dist[1], 0.1)

plt.plot(x_arr, [h(x) for x in x_arr])
plt.show()
