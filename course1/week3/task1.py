#
# Задача 1. Минимизация гладкой функции Рассмотрим все ту же функцию из задания по линейной алгебре:
# f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2), но теперь уже на промежутке [1, 30]
#
# В первом задании будем искать минимум этой функции на заданном промежутке с помощью scipy.optimize. Разумеется,
# в дальнейшем вы будете использовать методы оптимизации для более сложных функций, а f(x) мы рассмотрим как удобный
# учебный пример.
#
# Напишите на Питоне функцию, вычисляющую значение f(x) по известному x. Будьте внимательны: не забывайте про то,
# что по умолчанию в питоне целые числа делятся нацело, и о том, что функции sin и exp нужно импортировать из модуля
# math.
#
# Изучите примеры использования  scipy.optimize.minimize в документации Scipy (см. "Материалы")
#
# Попробуйте найти минимум, используя стандартные параметры в функции  scipy.optimize.minimize (т.е. задав только
# функцию и начальное приближение). Попробуйте менять начальное приближение и изучить, меняется ли результат.
#
# Укажите в scipy.optimize.minimize в качестве метода BFGS (один из самых точных в большинстве случаев градиентных
# методов оптимизации), запустите из начального приближения x=2. Градиент функции при этом указывать не нужно – он
# будет оценен численно. Полученное значение функции в точке минимума - ваш первый ответ по заданию 1,
# его надо записать с точностью до 2 знака после запятой.
#
# Теперь измените начальное приближение на x=30. Значение функции в точке минимума - ваш второй ответ по заданию 1,
# его надо записать через пробел после первого, с точностью до 2 знака после запятой.
#
# Стоит обдумать полученный результат. Почему ответ отличается в зависимости от начального приближения? Если
# нарисовать график функции (например, как это делалось в видео, где мы знакомились с Numpy, Scipy и Matplotlib),
# можно увидеть, в какие именно минимумы мы попали. В самом деле, градиентные методы обычно не решают задачу
# глобальной оптимизации, поэтому результаты работы ожидаемые и вполне корректные.

from math import sin, exp
from scipy import optimize
import numpy as np
from matplotlib import pyplot as plt

dist = [1, 30]


def f(x):
    return sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2)


def find_min(func, coord, method=None):
    return optimize.minimize(func, np.array(coord), method=method, tol=1e-7)


res = find_min(f, 2, "BFGS")
print(res)
print(round(f(res.x[0]), 2))

res = find_min(f, 30, "BFGS")
print(res)
print(round(f(res.x[0]), 2))

x_arr = np.arange(dist[0], dist[1], 0.1)

plt.plot(x_arr, [f(x) for x in x_arr])
plt.show()
